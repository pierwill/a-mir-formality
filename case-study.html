<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Case study: Implied bounds and perfect derive - The MIR Formality Book</title>


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="custom.css">

        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded affix "><li class="part-title">How Formality works</li><li class="chapter-item expanded "><a href="layers.html"><strong aria-hidden="true">2.</strong> Layers of formality</a></li><li class="chapter-item expanded "><a href="closer-look-ty.html"><strong aria-hidden="true">3.</strong> Closer look at ty</a></li><li class="chapter-item expanded "><a href="closer-look-decl.html"><strong aria-hidden="true">4.</strong> Closer look at decl</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.</strong> Closer look at mir</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.</strong> Closer look at mir-op</div></li><li class="chapter-item expanded affix "><li class="part-title">What Formality can do</li><li class="chapter-item expanded "><a href="case-study.html" class="active"><strong aria-hidden="true">7.</strong> Case study: Implied bounds and perfect derive</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The MIR Formality Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="case-study-implied-bounds-and-perfect-derive"><a class="header" href="#case-study-implied-bounds-and-perfect-derive">Case study: Implied bounds and perfect derive</a></h1>
<p>The <a href="https://github.com/nikomatsakis/rust-name-resolution-algorithm/tree/ccc9599e0db39afa3516cedf059e434d0810be6f">current code</a> doesn't really model Rust as it is today.
It actually models Rust extended with support for two new features:
&quot;implied bounds&quot; and &quot;perfect derive&quot;.</p>
<p><strong>Implied bounds:</strong>
Given <code>struct Foo&lt;T: Ord&gt;</code>, can <code>impl&lt;T&gt; Foo&lt;T&gt; { ... }</code> just know that <code>T: Ord</code>?
We actually have implied bounds today, but they are limited to supertraits (e.g., <code>T: Eq =&gt; T: PartialEq</code>),
so maybe a better way to describe implied bounds would be <em>expanded implied bounds</em>.</p>
<p><strong>Perfect derive:</strong>
Given <code>#[derive(Clone)] struct Foo&lt;T&gt; { x: Rc&lt;T&gt; }</code>,
we &quot;just know&quot; that <code>impl&lt;T&gt; Clone for Foo&lt;T&gt;</code> works,
and that <code>T: Clone</code> is not necessary?
The idea is that <code>derive</code> would generate <code>impl&lt;T&gt; Clone for Foo&lt;T&gt; where Rc&lt;T&gt;: Clone</code>.
Seems simple, right?
The trick is that we have to extend all trait matching to work like auto-traits does,
and accept cycles.
Consider deriving clone on * <code>struct List&lt;T&gt; { value: Rc&lt;T&gt;, next: Option&lt;Rc&lt;List&lt;T&gt;&gt;&gt; }</code>.
Here you would get <code>impl&lt;T&gt; Clone for List&lt;T&gt; where Rc&lt;T&gt;: Clone, Option&lt;Rc&lt;List&lt;T&gt;&gt;&gt;: Clone</code>.
If you try that today, you'll find it is a cycle error.
We are going to refer to this &quot;accept cycles&quot; as coinductive;
it's basically the co-LP formulation by <a href="https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.102.9618&amp;rep=rep1&amp;type=pdf">Luke Simon et al.</a> that I referred to earlier.</p>
<p>These two features are a bit tricky to integrate because accepting cycles, 
if you're not careful, can easily lead you into assuming implied bounds that are not true.
The classic example is this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Copy { }
trait Magic: Copy { }
<span class="boring">}
</span></code></pre></pre>
<p>Clearly, given these traits, we know that <code>T: Magic =&gt; T: Copy</code>, right?
But what about if someone writes this rather tautological impl:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T: Magic&gt; Magic for T { }
<span class="boring">}
</span></code></pre></pre>
<p>If we're not careful, we can use this impl to show that every type implements <code>Magic</code> --
and yet there is no <code>impl Copy</code> anywhere.
Something is off!</p>
<p>The solution to that is based on the scheme that <a href="https://github.com/scalexm">scalexm</a> invented for Chalk;
I've tweaked it somewhat by integrating it a bit more deeply into the &quot;core logic&quot;,
which simplifies the predicates that we need.
I find I like this formulation better, and it allows us to simplify a few other things too.</p>
<h3 id="distinguish-hasimpl-and-implemented"><a class="header" href="#distinguish-hasimpl-and-implemented">Distinguish <code>HasImpl</code> and <code>Implemented</code></a></h3>
<p>The first key part of the system
is to distinguish <em>having an impl</em> (<code>HasImpl</code>) from <em>being implemented</em> (<code>Implemented</code>).
The former says that the user wrote an <code>impl</code> block.
The latter says that all the requirements are met to implement the trait,
including in particular that all of its where clauses (which includes the supertraits) are satisfied.</p>
<p>Using the code for impls we saw earlier, the <code>Magic</code> impl would generate the following clause:</p>
<pre><code class="language-scheme">; forall&lt;T&gt; { Implemented(T: Magic) =&gt; HasImpl(T: Magic) }
(ForAll ((TyKind T)) 
        (Implies ((Implemented (Magic (T))))
                 (HasImpl (Magic (T)))))
</code></pre>
<p>To actually prove <code>Implemented(T: Magic)</code>,
this clause has to be combined with the clauses generated by the trait declarations (<a href="https://github.com/nikomatsakis/a-mir-formality/blob/47eceea34b5f56a55d781acc73dca86c996b15c5/src/decl/decl-to-clause.rkt#L95-L118">source</a>).
For the <code>Copy</code> trait, which has no where clauses, this clause is very simple.
To be implemented, the impl must exist, and the type must be well-formed:</p>
<pre><code class="language-scheme">; forall&lt;T&gt; { (
;               HasImpl(T: Copy), 
;               WellFormed(T),
;             ) =&gt; Implemented(T: Copy) }
(ForAll ((TyKind T))
        (Implies ((HasImpl (Copy (T)))
                  (WellFormed (TyKind (T))))
                 (Implemented (Copy (T)))))
</code></pre>
<p>For <code>Magic</code>, the rule includes the where clause that <code>T: Copy</code>:</p>
<pre><code class="language-scheme">; forall&lt;T&gt; { (
;               HasImpl(T: Magic), 
;               WellFormed(T),
;               Implemented(T: Copy),
;             ) =&gt; Implemented(T: Magic) }
(ForAll ((TyKind T))
        (Implies ((HasImpl (Magic (T)))
                  (WellFormed (TyKind (T)))
                  (Implemented (Copy (T))))
                 (Implemented (Magic (T)))))
</code></pre>
<p>Now we start to see how this works -- 
if I want to call a function with a <code>T: Magic</code> where clause, like this...</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn make_the_magic_happen&lt;T: Magic&gt;(t: T) {
    let u = t;
    drop((t, u)); // both t, u are valid
}
<span class="boring">}
</span></code></pre></pre>
<p>...it is not enough to show that <code>HasImpl</code> is satisfied, I also have to prove that <code>T: Copy</code>
To do that, I have to show that <code>HasImpl(T: Copy)</code>, and I can't do that.</p>
<h3 id="but-wait-implied-bounds"><a class="header" href="#but-wait-implied-bounds">But wait, implied bounds?</a></h3>
<p>Actually though, the above is not sufficient to solve the problem
That's because we haven't added in implied bounds yet! The <em>naive</em> version of implied bounds is that we want to add in a rule like so:</p>
<pre><code>Implemented(T: Magic) =&gt; Implemented(T: Copy)
</code></pre>
<p>i.e., if I know that <code>T: Magic</code>, I also know that <code>T: Copy</code>
But if we literally added that clause, it would be unsound, at least in a coinductive setting
Why is that? Say I want to prove that <code>String: Copy</code>...</p>
<ul>
<li><code>Implemented(String: Copy)</code>? Well, that's true if...
<ul>
<li><code>Implemented(String: Magic)</code>? Well, that's true if...
<ul>
<li><code>HasImpl(String: Magic)</code>? Well, that's true if...
<ul>
<li><code>Implemented(String: Magic)</code> -- and that's on the stack, so that's ok!</li>
</ul>
</li>
<li><code>WellFormed(String)</code> -- yep</li>
<li><code>Implemented(String: Copy)</code> -- well, that's on the stack, so that's ok!</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>The traditional solution so this sort of problem is to impose some kind of limits on the impls people can write so they must be &quot;productive&quot;
It's a bit tricky to define what productivity means, but intuitively it means &quot;not tautological&quot;
The challenge is that the various schemes I've seen for showing productivity don't accept impls like the ones that perfect derive would create, so they wouldn't really work for us.
The solution in the impl works a different way.</p>
<p>The co-LP formulation acccepts any cycle as valid, so it's very easy to create these kind of &quot;tautological rules&quot;.
Now, if the user actually <em>wrote</em> those impls, I don't see that as a problem.
It's ok to have mutually dependent impls, all we want to know basically is &quot;when I call a method, there will be some impl to go to&quot; (see example below).
But it's not good if it's unsound. =)</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo {
    fn foo(&amp;self);
}

trait Bar {
    fn bar(&amp;self);
}

impl&lt;T: Bar&gt; Foo for T {
    fn foo(&amp;self) {
        if something() { self.bar() }
    }
}

impl&lt;T: Foo&gt; Bar for T {
    fn bar(&amp;self) {
        if something() { self.foo() }
    }
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="enter-invariants"><a class="header" href="#enter-invariants">Enter: invariants</a></h3>
<p>The insight is that it's not ok to use implied bounds out of thin air.
You only want to use them for where-clauses that you have in scope.
In this way, they are categorically different from program clauses, which always hold.
I've decided to refer to implied bounds as <em>invariants</em> -- the idea is that they are things which &quot;must be true if the program is valid&quot;.
So for our program we would have one <strong>invariant</strong>:</p>
<pre><code>forall&lt;T&gt; { Implemented(T: Magic) =&gt; Implemented(T: Copy) }
</code></pre>
<p>To express this a bit more formally, let <code>F</code> be the set of all &quot;facts&quot; we can generate from the clauses alone (a &quot;fact&quot; here is just a predicate that refers to some concrete types and thing)s.
Because there are an infinite set of types, the set of facts is also infinite, but that's ok.
In our example, given the rules we've seen so far (but ignoring the implied bound), we can show that <code>HasImpl(i32: Magic)</code> and <code>HasImpl(u32: Magic)</code> easily enough.
We don't have a <code>HasImpl(i32: Copy)</code> fact, though, and because of that we also can't have a <code>Implemented(i32: Copy)</code> fact.
Given this set of facts <code>F</code>, then we ought to be able to prove each invariant <code>I</code>, or something is broken in our type rules.
In our example, the invariant <code>forall&lt;T&gt; { Implemented(T: Magic) =&gt; Implemented(T: Copy) }</code> does in fact hold, because there are no <code>Implemented(T: Magic)</code> facts.</p>
<h3 id="integrating-invariants-into-the-solver"><a class="header" href="#integrating-invariants-into-the-solver">Integrating invariants into the solver</a></h3>
<p>The solver is able to make use of invariants to generate proofs, but only in a limited way.
Whereas we can always use a program clause, we can only apply invariants to the <em>hypotheses</em> that are in scope -- a <em>hypotheses</em> is some where-clause that we are assuming to be true.
The idea here is that the caller must have proven that hypothesis to be a <em>fact</em> -- if they did so, then unless our type rules are broken, the invariant holds, which means that any facts we can derive with the invariants are also true.</p>
<p>This in turn implies that the seemingly tautological impl of <code>Magic</code> is actually <strong>legal</strong>! Recall the &quot;ok goals&quot; we saw before, that are used to decide which declarations are legal.
The &quot;ok&quot; goal for the magic impl looks like this:</p>
<pre><code class="language-scheme">(ForAll ((TyKind T))
        (Implies ((Implemented (Magic (T))))
                 (Implemented (Magic (T)))))
</code></pre>
<p>Basically, &quot;if we assume that <code>T: Magic</code> is implemented, then we can show that <code>T: Magic</code> is implemented&quot;.
Well, that's obviously true.</p>
<p>OK, so the impl is legal, but what about this function <code>make_the_magic_happen</code>?</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn make_the_magic_happen&lt;T: Magic&gt;(t: T) {
    let u = t;
    drop((t, u)); // both t, u are valid
}
<span class="boring">}
</span></code></pre></pre>
<p>We don't currently have type-checking logic in Formality
but, if we did, type-checking this function would require copying <code>t</code> and hence proving that:</p>
<pre><code>forall&lt;T&gt; {
    Implemented(T: Magic) =&gt; Implemented(T: Copy)
}
</code></pre>
<p>Here the <code>Implemented(T: Magic) =&gt; ...</code> comes from the where-clauses on the function.
To solve this, the solver puts <code>Implemented(T: Magic)</code> into the environment as a hypothesis using the &quot;prove-implies&quot; rule (<a href="https://github.com/nikomatsakis/a-mir-formality/blob/47eceea34b5f56a55d781acc73dca86c996b15c5/src/ty/cosld-solve/prove.rkt#L67-L71">source</a>):</p>
<pre><code class="language-scheme">  [(where Env_1 (env-with-hypotheses Env Hypotheses))
   (prove Env_1 Predicates_stack Goal EnvSubstitution_out)
   -------------------------------------------------------- &quot;prove-implies&quot;
   (prove Env Predicates_stack (Implies Hypotheses Goal) (reset Env () EnvSubstitution_out))
   ]
</code></pre>
<p>Next it can apply the &quot;prove-hypothesis-imply&quot; rule (<a href="https://github.com/nikomatsakis/a-mir-formality/blob/47eceea34b5f56a55d781acc73dca86c996b15c5/src/ty/cosld-solve/prove.rkt#L41-L45">source</a>):</p>
<pre><code class="language-scheme">  [(where #f (in? Predicate Predicates_stack))
   (Hypotheses-imply Env () Predicate EnvSubstitution_out)
   --------------- &quot;prove-hypotheses-imply&quot;
   (prove Env Predicates_stack Predicate EnvSubstitution_out)
   ]
</code></pre>
<p>This rule usess <a href="https://github.com/nikomatsakis/a-mir-formality/blob/47eceea34b5f56a55d781acc73dca86c996b15c5/src/ty/cosld-solve/hypothesize.rkt#L9-L11"><code>Hypotheses-imply</code></a>, another typing judgment which determines whether <code>Predicate</code> is either <em>directly</em> in the environment as a hypothesis <strong>or can be derived via an invariant</strong>.
This last part is what we need here! The only hypothesis in the environment is <code>Implemented(T: Magic)</code>, but we can use the invariant</p>
<pre><code>Implemented(T: Magic) =&gt; Implemented(T: Copy)
</code></pre>
<p>to expand that to <code>Implemented(T: Copy)</code>, so we are happy.</p>
<h3 id="wait-so-is-this-sound"><a class="header" href="#wait-so-is-this-sound">Wait, so is this sound?</a></h3>
<p>But accepting this impl and this function this doesn't mean we have an unsound program -- the question is, who is going to <em>call</em> that function, and with what type? And this is where the errors come in.
Consider this <code>main</code> function:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    make_the_magic_happen(&quot;Die, cruel world, die!&quot;.to_string());
}
</code></pre></pre>
<p>For this program to type-check, we must prove the where-clauses on <code>make_the_magic_happen</code>, which means proving</p>
<pre><code>Implemented(String: Magic)
</code></pre>
<p>But in this case, there are no hypotheses in the environment, so we can't make use of the invariants.
We have to use the program clause, it requires also showing that <code>Implemented(String: Copy)</code> which in turn means showing <code>HasImpl(String: Copy)</code>, and we cannot do that.</p>
<p>Thinking a bit more abstractly, no matter what where clauses we have on various functions, we will &quot;bottom out&quot; in a <code>main</code> function somewhere, and <code>main</code> has no where clauses.
Therefore, if our program relies on <code>Implemented(i32: Magic)</code>, that must be provable in an environment with no hypotheses.
Put another way, <code>Implemented(i32: Magic)</code> must be a member of that infinite set of facts that we described earlier, the ones which categorize &quot;everything that is true in this program&quot;.
But we already argued that this set does not include <code>Implemented(i32: Magic)</code>, because the only way to get such a fact is to use the program clause, and the program clause requires that <code>HasImpl(i32: Copy)</code>, which is not true.</p>
<!--
### Productivity again?

xxx -- didn't get time to to finish this, but I think that you can frame the previous two sections in terms of the typical "productivity" rules.
There is a nice thesis I've been slowly working through on this.
The TL;DR is something like this: "we accept all cycles but require that for any proof of `Implemented(T: Foo)`, `HasImpl(T: Foo)` must appear somewhere in the cycle", but that's not quite stating it right.
-->

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="closer-look-decl.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="closer-look-decl.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            var socket = new WebSocket("ws://localhost:3000/__livereload");
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->


    </body>
</html>
