"use strict";(self.webpackChunka_mir_formality=self.webpackChunka_mir_formality||[]).push([[671],{3905:function(e,t,n){n.d(t,{Zo:function(){return c},kt:function(){return d}});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=r.createContext({}),u=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=u(e.components);return r.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),m=u(n),d=a,h=m["".concat(l,".").concat(d)]||m[d]||p[d]||o;return n?r.createElement(h,i(i({ref:t},c),{},{components:n})):r.createElement(h,i({ref:t},c))}));function d(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,i=new Array(o);i[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:a,i[1]=s;for(var u=2;u<o;u++)i[u]=n[u];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}m.displayName="MDXCreateElement"},9881:function(e,t,n){n.r(t),n.d(t,{assets:function(){return c},contentTitle:function(){return l},default:function(){return d},frontMatter:function(){return s},metadata:function(){return u},toc:function(){return p}});var r=n(7462),a=n(3366),o=(n(7294),n(3905)),i=["components"],s={sidebar_position:1},l="Introduction",u={unversionedId:"intro",id:"intro",title:"Introduction",description:"A MIR Formality (or just Formality) is an early-stage experimental project that aims to be",source:"@site/docs/intro.md",sourceDirName:".",slug:"/intro",permalink:"/a-mir-formality/docs/intro",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/intro.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",next:{title:"Setup",permalink:"/a-mir-formality/docs/setup"}},c={},p=[],m={toc:p};function d(e){var t=e.components,n=(0,a.Z)(e,i);return(0,o.kt)("wrapper",(0,r.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"introduction"},"Introduction"),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"A MIR Formality")," (or just Formality) is an early-stage experimental project that aims to be\na complete, authoritative formal model of the ",(0,o.kt)("a",{parentName:"p",href:"https://rustc-dev-guide.rust-lang.org/mir/index.html"},"Rust MIR"),".\nThe project has two goals.\nFirst, the models of Rust's MIR given by Formality's will serve as a complete model for Rust,\nincluding both its type checking rules (what programs are accepted) and semantics (what happens when you run them on an idealized machine).\nThis will provide a source of truth."),(0,o.kt)("p",null,'Presuming these experiments bear fruit,\nthe intention is to bring this model into Rust as an RFC\nand develop it as an official part of the language definition.\nWe hope Formality will become the "primary source" for "what Rust means".'),(0,o.kt)("p",null,"The goal of this document is to explain the project's structure as well\nas give a sense of the overall development roadmap we have in mind."),(0,o.kt)("h1",{id:"the-problem"},"The problem"),(0,o.kt)("p",null,"Currently, Rust's semantics are defined ultimately by the compiler.\nWhere more specific definitions were wanted, in the past we have created is to have targeted models.\nBut we're running up against the limit of what you can achieve that way.\nUnsoundness arises in the \"intersection\" of different things,\nand the system is too complex for us to keep in our heads.\nOn the other hand, writing Rust code is too slow and inflexible.\nWriting a formal model helps us to scale."),(0,o.kt)("p",null,'Formality will give us a living, executable, and extensible model for Rust.\nWe imagine a future in which whenever a new language feature is designed,\none stage in the process will be formalizing that feature into Formality.\nCurrently, Formality focuses on MIR, which mean this will only make sense for "core language features"\nlike implied bounds or specialization.\nEventually we\'d like to extend Formality to cover other areas\nlike name resolution and Rust surface syntax.\nThis will help to uncover interactions between features.'),(0,o.kt)("p",null,"For the trait solver, Formality will map quite closely to its overall structure,\nwhich allows us to experiment with new algorithms or structure and see their effects quickly.\nEarly prototyping includes approaches for such concepts as\nassociated type normalization, perfect bounds, and subtyping.\nThese are not always features that users see directly.\nInstead, Formality allows the Rust language\nto take advantage of type theory and other formal work on programming languages\nin a way that can give a satisfying definition of the language,\nand a practical tool for ensuring Rust has a solid foundation\n(much as the ",(0,o.kt)("a",{parentName:"p",href:"https://www.amazon.science/publications/using-lightweight-formal-methods-to-validate-a-key-value-storage-node-in-amazon-s3"},"AWS S3 team does to check their code"),")."),(0,o.kt)("h1",{id:"why-plt-redex"},"Why PLT Redex?"),(0,o.kt)("p",null,"Rust is a big language, with lots of features.\nAs a community of open source maintainers, programmers and researchers of all kinds,\nwe need a shared, well-known way of specifying the language.\nWe want to decide what Rust programs are:\nhow they are constructed (their syntax) and what they do (semantics)."),(0,o.kt)("p",null,"MIR Formality is written in PLT Redex, a domain-specific language for working with semantics.\nRedex is part of Racket, a LISP-like language popular in programming language research.\nRedex programs are ",(0,o.kt)("em",{parentName:"p"},"executable models"),".\nIt allows langauge designers to write very high-level structures, execute them, and see what happens.\nPLT/Redex allows us to realize the dream of a One True Rust in a practical way,\nchecking ",(0,o.kt)("inlineCode",{parentName:"p"},"rustc")," against a source of truth."))}d.isMDXComponent=!0}}]);