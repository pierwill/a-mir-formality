<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The MIR Formality Book</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="custom.css">

        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded affix "><li class="part-title">How Formality works</li><li class="chapter-item expanded "><a href="layers.html"><strong aria-hidden="true">2.</strong> Layers of formality</a></li><li class="chapter-item expanded "><a href="closer-look-ty.html"><strong aria-hidden="true">3.</strong> Closer look at ty</a></li><li class="chapter-item expanded "><a href="closer-look-decl.html"><strong aria-hidden="true">4.</strong> Closer look at decl</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.</strong> Closer look at mir</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.</strong> Closer look at mir-op</div></li><li class="chapter-item expanded affix "><li class="part-title">What Formality can do</li><li class="chapter-item expanded "><a href="case-study.html"><strong aria-hidden="true">7.</strong> Case study: Implied bounds and perfect derive</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The MIR Formality Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="a-mir-formality"><a class="header" href="#a-mir-formality">A MIR Formality</a></h1>
<p>A MIR Formality (or just Formality) is an early-stage experimental project that aims to be
a complete, authoritative formal model of the <a href="https://rustc-dev-guide.rust-lang.org/mir/index.html">Rust MIR</a>.
Presuming these experiments bear fruit,
the intention is to bring this model into Rust as an RFC
and develop it as an official part of the language definition.
We hope Formality will become the &quot;primary source&quot; for &quot;what Rust means&quot;.</p>
<p>The goal of this document is to explain the project's structure as well
as give a sense of the overall development roadmap we have in mind.</p>
<!-- Currently, Rust's semantics are defined ultimately by the compiler. -->
<p>What we've done in the past is to have targeted models.
But we're running up against the limit of what you can achieve that way.
Unsoundness arises in the &quot;intersection&quot; of different things,
and the system is too complex for us to keep in our heads.
On the other hand, writing Rust code is too slow and inflexible.
Writing a formal model helps us to scale.</p>
<p>Formality will give us a living, executable, and extensible model for Rust.
We imagine a future in which whenever a new language feature is designed,
one stage in the process will be formalizing that feature into Formality.
Currently, Formality focuses on MIR, which mean this will only make sense for &quot;core language features&quot;
like implied bounds or specialization.
Eventually we'd like to extend Formality to cover other areas
like name resolution and Rust surface syntax.
This will help to uncover interactions between features.</p>
<p>Formality also can be fuzzed and checked against rustc,
much as the <a href="https://www.amazon.science/publications/using-lightweight-formal-methods-to-validate-a-key-value-storage-node-in-amazon-s3">AWS S3 team does to check their code</a>.</p>
<p>We can extend rustc to generate formality declarations.</p>
<!-- What does this mean? -->
<p>For the trait solver, formality will map quite closely to its overall structure,
which allows us to experiment with new algorithms or structure and see their effects quickly.
As an initial example, I plan to prototype a new approach for associated type normalization.</p>
<!--
## Previous approaches?
I had originally hoped that chalk could serve as a kind of "executable semantics" for Rust.
The idea was that the separation between "generating clauses" and "the solver"
would allow us to specify how Rust works on a high-enough level that the code is nicely generic.
Over time, though, I've become convinced that this approach won't scale.
There is a lot of "incidental complexity" that is created by integrating chalk into rustc,
as well as engineering for efficiency.
Ultimately, I don't see chalk being sufficiently malleable for our purposes.
-->
<h1 id="why-plt-redex"><a class="header" href="#why-plt-redex">Why PLT Redex?</a></h1>
<p>MIR Formality is written in PLT Redex, a domain-specific language for working with semantics.
Redex is part of Racket,
a LISP-like language popular in programming language research.</p>
<p>It allows you to write very high-level structures, execute them, and see what happens.</p>
<p>I think it's sufficiently approachable that we can onboard contributors and grow the types team.
I'm not sure the same is true of other alternatives.</p>
<p>Redex also supports fuzzing.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="layers-of-formality"><a class="header" href="#layers-of-formality">Layers of Formality</a></h1>
<p>Formality is structured into several layers.
These layers are meant to map fairly closely onto Chalk and the eventual Rust trait solver implementation.
Ideally, one should be able to map back and forth between Formality and corresponding Rust code with relative ease.</p>
<!-- "the code": the rustc code? Chalk code? redex code? -->
<h2 id="the-types-layer-formality-ty"><a class="header" href="#the-types-layer-formality-ty">The types layer (<code>formality-ty</code>)</a></h2>
<p>Defines Rust types and functions for equating/relating them.
The representation is meant to cover all Rust types,
but is optimized for extracting their &quot;essential properties&quot;.</p>
<p>Defines core logical predicates (<code>Implemented(T: Trait)</code>, etc) and solvers.
This layer does not define what they <em>mean</em> -- i.e., the conditions in which they are true.</p>
<h2 id="the-declarations-layer-formality-decl"><a class="header" href="#the-declarations-layer-formality-decl">The declarations layer (<code>formality-decl</code>)</a></h2>
<p>Defines Rust's &quot;top-level items&quot; and their semantics.
This includes crates, structs, traits, impls, but excludes function bodies.</p>
<!-- can we be more specific than "top-level items" -->
<!-- will it always exclude functions? -->
<p>Semantics are defined by converting Rust items into predicates.
For example, <code>impl&lt;T: Eq&gt; Eq for Vec&lt;T&gt;</code> becomes a &quot;program clause&quot; (axiom)
like <code>forall&lt;T&gt; { Implemented(T: Eq) =&gt; HasImpl(Vec&lt;T&gt;: Eq) }</code>.
(The distinction between <code>HasImpl</code> and <code>Implemented</code> is covered below.)</p>
<p>This layer also defines the well-formedness checks for those items.
For example, <code>struct Foo { f1: T1 }</code> is well-formed if <code>T</code> is well-formed.</p>
<h2 id="the-mir-type-system-layer-formality-mir"><a class="header" href="#the-mir-type-system-layer-formality-mir">The MIR type system layer (<code>formality-mir</code>)</a></h2>
<p>Defines the MIR and rules for its type checker.
This corresponds roughly to the MIR borrow checker + polonius.</p>
<!-- Nick: and the type checker (and trait system) too, or is this just about lifetime checking? -->
<!-- Niko: all the things  -->
<!-- Niko: note that the MIR borrow checker includes a type checker -->
<h2 id="the-mir-operational-semantics-layer-formality-mir-op"><a class="header" href="#the-mir-operational-semantics-layer-formality-mir-op">The MIR operational semantics layer (<code>formality-mir-op</code>)</a></h2>
<p>Extends the above level with an operational semantics.
Basically equivalent to miri.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="a-closer-look-at-formality-ty"><a class="header" href="#a-closer-look-at-formality-ty">A closer look at <code>formality-ty</code></a></h2>
<p>Let's take a closer look at the <code>formality-ty</code> layer.</p>
<h3 id="defining-rust-types"><a class="header" href="#defining-rust-types">Defining Rust types</a></h3>
<p>The current definition of types looks like this:</p>
<pre><code class="language-scheme">(define-language formality-ty
  ...
  (Ty :=
      (TyApply TyName Parameters) ; Application type
      VarId                       ; Bound or existential (inference) variable
      (! VarId)                   ; Universal (placeholder) variable
      )
  (TyName :=
          AdtId           ; enum/struct/union
          TraitId         ; trait
          AssociatedTy    ; Associated type
          ScalarId        ; Something like i32, u32, etc
          (Ref MaybeMut)  ; `&amp;mut` or `&amp;`, expects a lifetime + type parameter
          (Tuple number)  ; tuple of given arity
          )
   ...
   (ScalarId := i8 u8 i16 u16 i32 u32 i64 u64 i128 u128 bool)
   ...
   (AssociatedTy := (TraitId AssociatedTyId))
   ...
   (Parameters := (Parameter ...))
   (Parameter := Ty Lt)
   ...
   ((AdtId VarId TraitId AssociatedTyId AnyId) := variable-not-otherwise-mentioned)
)
</code></pre>
<p><span class="caption"><a href="https://github.com/nikomatsakis/a-mir-formality/blob/47eceea34b5f56a55d781acc73dca86c996b15c5/src/ty/grammar.rkt#L25-L37">Source</a></span></p>
<p>This definition is far from complete,
but it should give you some idea for the level of abstraction we are shooting for
and also how PLT Redex works.
The idea here is that a type is either a variable,
a placeholder that represents a generic type,
or an &quot;application&quot; of a type name to some parameters.
Let's see some examples:</p>
<ul>
<li>A generic type like <code>T</code> could either be <code>T</code> or <code>(! T)</code>:
<ul>
<li><code>T</code> is used when the generic has yet to be substituted, e.g., as part of a declaration.</li>
<li><code>(! T)</code> is used as a placeholder to &quot;any type <code>T</code>&quot;.</li>
</ul>
</li>
<li>A type like <code>Vec&lt;T&gt;</code> in Rust would be represented therefore as:
<ul>
<li><code>(TyApply Vec (T))</code>, in a declaration; or,</li>
<li><code>(TyApply Vec ((! T)))</code> when checking it.</li>
</ul>
</li>
<li>A scalar type like <code>i32</code> is represented as <code>(TyApply i32 ())</code>.</li>
</ul>
<p>As I said, this defintion of types is woefully incomplete. I expect it to eventually include:</p>
<ul>
<li>&quot;alias types&quot; like associated types and type aliases</li>
<li>&quot;existential&quot; types like <code>dyn</code></li>
<li>&quot;forall&quot; quantifies to cover <code>for&lt;'a&gt; ...</code></li>
<li>&quot;function&quot; types <code>fn(A1...An) -&gt; R</code></li>
<li>&quot;implication&quot; types <code>where(...) T</code> (these don't exist in Rustâ€”yet)</li>
</ul>
<p>You can also see that the definition of types is aligned to highlight their &quot;essential&quot; characteristics
and not necessarily for convenience elsewhere.
Almost every Rust type, for example, boils down to <em>some</em> kind of &quot;application&quot;
(it's likely that we can even represent <code>fn</code> types this way).</p>
<h3 id="type-unification"><a class="header" href="#type-unification">Type unification</a></h3>
<p>A key part of the type layer is that it includes <em>type unification</em>.
That is, it defines the rules for making types equal.
This will eventually have to be extended to cover subtyping (more on that a bit later)
so that we can properly handle variance.</p>
<p>Unification is accomplished in PLT Redex with a &quot;<a href="https://docs.racket-lang.org/redex/reference.html#%28form._%28%28lib._redex%2Freduction-semantics..rkt%29._define-metafunction%29%29">metafunction</a>&quot;,
which just means a function that operates on terms
(versus a function in the Rust program being analyzed):</p>
<pre><code class="language-scheme">(define-metafunction formality-ty
  most-general-unifier : Env TermPairs -&gt; EnvSubstitution or Error
</code></pre>
<p>This function takes an environment <code>Env</code> and a list of pairs of terms that should be equated and gives back either:</p>
<ul>
<li>a new environment and substitution from inference variables to values that will make the two terms syntactically equal; or,</li>
<li>the term <code>Error</code>, if they cannot be unified.</li>
</ul>
<p>The unifier is a bit smarter than the traditional unification
in that it knows about <em>universes</em> and so can handle &quot;forall&quot; proofs and things
(that's what is found in the environment).
This is the same as chalk and rustc.</p>
<p>I won't cover the details but I'll just give an example.
This is actually modified from a unit test from the code
(<a href="https://github.com/nikomatsakis/a-mir-formality/blob/47eceea34b5f56a55d781acc73dca86c996b15c5/src/ty/unify.rkt#L254-L269">source</a>).
Invoking <code>most-general-unifier</code> like so:</p>
<pre><code class="language-scheme">(most-general-unifier Env_2 ((A X)
                             (X (TyApply Vec (Y)))
                             (Y (TyApply i32 ()))))
</code></pre>
<!-- maybe: `A == X`,  `X == Vec<Y>`, and `Y == i32` -->
<p>corresponds to saying that <code>[A = X, X = Vec&lt;Y&gt;, Y = i32]</code> must all be true,
where <code>A</code>, <code>X</code> and <code>Y</code> are inference variables.
The resulting output is a substitution that maps <code>A</code>, <code>X</code>, and <code>Y</code> to the following values:</p>
<ul>
<li><code>A -&gt; Vec&lt;i32&gt;</code></li>
<li><code>X -&gt; Vec&lt;i32&gt;</code></li>
<li><code>Y -&gt; i32</code></li>
</ul>
<h3 id="predicates"><a class="header" href="#predicates">Predicates</a></h3>
<p><code>formality-ty</code> also defines the core predicates used to define Rust semantics.
The current definition is as follows (<a href="https://github.com/nikomatsakis/a-mir-formality/blob/47eceea34b5f56a55d781acc73dca86c996b15c5/src/ty/grammar.rkt#L121-L130">source</a>):</p>
<pre><code class="language-scheme">(Predicate :=
           ; `TraitRef` is (fully) implemented.
           (Implemented TraitRef)
           ; an impl exists for `TraitRef`; this *by itself* doesn't mean
           ; that `TraitRef` is implemented, as the supertraits may not
           ; have impls.
           (HasImpl TraitRef)
           ; the given type or lifetime is well-formed.
           (WellFormed (ParameterKind Parameter))
           )
</code></pre>
<p>These core predicates are then used to define a richer vocabulary of goals (things that can be proven)
and various kinds of &quot;clauses&quot; (things that are assumed to be true, axioms)
(<a href="https://github.com/nikomatsakis/a-mir-formality/blob/47eceea34b5f56a55d781acc73dca86c996b15c5/src/ty/grammar.rkt#L136-L143">source</a>):</p>
<pre><code class="language-scheme">  (Goals = (Goal ...))
  (Goal :=
        Predicate
        (Equate Term Term)
        (All Goals)
        (Any Goals)
        (Implies Hypotheses Goal)
        (Quantifier KindedVarIds Goal)
        )

  ((Hypotheses Clauses Invariants) := (Clause ...))
  ((Hypothesis Clause Invariant) :=
                                 Predicate
                                 (Implies Goals Predicate)
                                 (ForAll KindedVarIds Clause)
                                 )
</code></pre>
<p>Importantly, the <em>types layer</em> defines a solver that gives semantics to all the &quot;meta&quot; parts of goals and clauses -- e.g., it defines what it means to prove <code>(All (G1 G2))</code> (prove both <code>G1</code> and <code>G2</code>, duh). But it doesn't have any rules for what it means to prove the <em>core</em> predicates true -- so it could never prove <code>(Implemented (Debug ((! T))))</code>. Those rules all come from the declaration layer and are given to the types layer as part of the &quot;environment&quot;.</p>
<h4 id="goals-versus-clauses"><a class="header" href="#goals-versus-clauses">Goals versus clauses</a></h4>
<p>You might be curious about the distinction between goal and clause
and why there are so many names for clauses (hypothesis, clause, invariant, etc).
Let's talk briefly about that.</p>
<p>The role of <code>ForAll</code> in goals and clauses is different.
Proving \( \forall X. G \) requires proving that <code>G</code> is true for any value of <code>X</code>
(i.e., for a placeholder <code>(! X)</code>, in our setup).
By contrast, if you know \( \forall X. G \) as an axiom,
it means that you can give <code>X</code> any value <code>X1</code> you want.
Clauses have a limited structure between that keeps the solver tractable.
The idea is that they are always &quot;ways to prove a single predicate&quot; true;
we don't allow a clause like <code>(Any (A B))</code> as a clause,
since that would mean &quot;A or B is true but you don't know which&quot;.
That would then be a second way to prove an <code>Any</code> goal like <code>(Any ...)</code>
and introduce lots of complications (we got enough already, thanks).</p>
<p>Further distinctions between &quot;hypotheses&quot;, &quot;clauses&quot;, and &quot;invariants&quot;
are used to express and capture implied bounds.
We'll defer a detailed analysis until the section below, but briefly:</p>
<ul>
<li>&quot;Hypotheses&quot; are where-clauses that are assumed to be true in this section of the code.</li>
<li>&quot;Clauses&quot; are global rules that are always true (derived, e.g., from an impl).</li>
<li>&quot;Invariants&quot; express implied bounds (e.g., supertrait relationships like &quot;if <code>T: Eq</code>, then <code>T: PartialEq</code>&quot;).</li>
</ul>
<h3 id="solver"><a class="header" href="#solver">Solver</a></h3>
<p>Putting all this together, the types layer currently includes a relatively simple solver called <code>cosld-solve</code>.
The name refers to the classic <a href="https://en.wikipedia.org/wiki/SLD_resolution">SLD Resolution Algorithm</a> that powers Prolog,
although the version of it that we've implemented is extended in two ways:</p>
<ul>
<li>It is coinductive (hence <code>cosld</code>) as <a href="https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.102.9618&amp;rep=rep1&amp;type=pdf">described by Luke Simon et al.</a>.
This means it permits cycles, roughly speaking.</li>
<li>It covers hereditary Harrop predicates using the <a href="https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.107.2510&amp;rep=rep1&amp;type=pdf">techniques described by Gopalan Nadathur</a>.</li>
</ul>
<p>In terms of chalk solvers, it is &quot;similar&quot; to slg, but much simpler in its structure (it doesn't do any caching).</p>
<p>All those fancy words aside, it's really quite simple.
It's defined via induction rules, which PLT Redex lets us write in a natural style with <a href="https://docs.racket-lang.org/redex/reference.html#%28form._%28%28lib._redex%2Freduction-semantics..rkt%29._define-judgment-form%29%29"><code>define-judgment-form</code></a>.
The definition begins like so:</p>
<pre><code class="language-scheme">(define-judgment-form formality-ty
  #:mode (prove I I I O)
  #:contract (prove Env Predicates_stack Goal EnvSubstitution)
</code></pre>
<p>This says that we are trying to prove something written as <code>(prove Env Predciates Goal EnvSubstitution)</code>,
where the first three are 'inputs' and the final name is an 'output'
(the input vs output distinction is often left implicit in Prolog and other languages).
The idea is that we will prove that <code>Goal</code> is true in some environment <code>Env</code>;
the environment contains our hypotheses and clauses, as well as information about the variables in scope.
The <code>Predicates</code> list is the stack of things we are solving, it's used to detect cycles.
The <code>EnvSubstitution</code> is the <em>output</em>, it is a modified environment
paired with a substitution that potentially gives new values to inference variables found in <code>Goal</code>.</p>
<p>Here is a simple rule.
It defines the way we prove <code>Any</code> (<a href="https://github.com/nikomatsakis/a-mir-formality/blob/main/src/ty/cosld-solve/prove.rkt#L62-L65">source</a>).
The notation is as follows.
The stuff &quot;above the line&quot; are the conditions that have to be proven;
the thing &quot;under the line&quot; is the conclusion that we can draw.</p>
<pre><code class="language-scheme">  [(prove Env Predicates_stack Goal_1 EnvSubstitution_out)
   ------------------------------------------------------- &quot;prove-any&quot;
   (prove Env Predicates_stack (Any (Goal_0 ... Goal_1 Goal_2 ...)) EnvSubstitution_out)
   ]
</code></pre>
<p>This rule says:</p>
<ul>
<li>Given some goal <code>(Any (Goal_0 ... Goal_1 Goal_2 ...))</code> where <code>Goal_1</code> is found somewhere in that list...
<ul>
<li>if we can prove <code>Goal_1</code> to be true, then the <code>Any</code> goal is true.</li>
</ul>
</li>
</ul>
<p>Or read another way:</p>
<ul>
<li>If we can prove <code>Goal_1</code> to be true, then we can prove <code>(Any Goals)</code> to be true so long as <code>Goal_1</code> is somewhere in <code>Goals</code>.</li>
</ul>
<p>It shows you a bit of the power of PLT Redex (and Racket's pattern matching), as well. We are able to write the rule in a &quot;non-deterministic&quot; way -- saying, &quot;pick any goal from the list&quot; and prove it. Redex will search all the possibilities.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="a-closer-look-at-formality-decl"><a class="header" href="#a-closer-look-at-formality-decl">A closer look at <code>formality-decl</code></a></h2>
<p>Now that we've surveyed the type layer, let's look at the declaration layer.
It begins by defining an &quot;extended&quot; language <code>formality-decl</code>
that adds new stuff to <code>formality-ty</code>:</p>
<pre><code class="language-scheme">(define-extended-language formality-decl formality-ty ...)
</code></pre>
<p><span class="caption"><a href="https://github.com/nikomatsakis/a-mir-formality/blob/47eceea34b5f56a55d781acc73dca86c996b15c5/src/decl/grammar.rkt#L5">Source</a></span></p>
<p>For example, a set of crates looks like this:</p>
<pre><code class="language-scheme"> (CrateDecls := (CrateDecl ...))
  (CrateDecl := (CrateId CrateContents))
  (CrateContents := (crate (CrateItemDecl ...)))
  (CrateItemDecl := AdtDecl TraitDecl TraitImplDecl)
</code></pre>
<p><span class="caption"><a href="https://github.com/nikomatsakis/a-mir-formality/blob/47eceea34b5f56a55d781acc73dca86c996b15c5/src/decl/grammar.rkt#L7-L10">Source</a></span></p>
<p>Basically a crate <code>a</code> is represented as a list of items like <code>(a (crate (item1 item2 item3)))</code>
where <code>item{1,2,3}</code> are either structs/enums (<code>AdtDecl</code>), traits (<code>TraitDecl</code>), or impls (<code>TraitImplDecl</code>).</p>
<h3 id="declaring-traits-in-formalitydecl"><a class="header" href="#declaring-traits-in-formalitydecl">Declaring traits in <code>FormalityDecl</code></a></h3>
<p>Let's look more closely at one of those kinds of items.
A trait declaration looks like this:</p>
<pre><code class="language-scheme">  (TraitDecl := (TraitId TraitContents))
  (TraitContents := (trait KindedVarIds WhereClauses TraitItems))
  ...
  (WhereClauses := (WhereClause ...))
  (WhereClause :=
               (ForAll KindedVarIds WhereClause)
               (Implemented TraitRef)
               )
</code></pre>
<p><span class="caption"><a href="https://github.com/nikomatsakis/a-mir-formality/blob/47eceea34b5f56a55d781acc73dca86c996b15c5/src/decl/grammar.rkt#L26-L27">Source</a></span></p>
<p>Here:</p>
<ul>
<li><code>TraitId</code> is the name of the trait</li>
<li><code>KindedVarIds</code> is a list of generic parameters like <code>((TyVar Self) (TyVar T))</code>.
Note that the <code>Self</code> parameter is made explicit. </li>
<li><code>WhereClauses</code> is a list of where-clauses, which are currently just <code>T: Foo</code> trait references
(though potentially higher-ranked).</li>
<li><code>TraitItems</code> are the contents of the trait, currently not used for anything.<!-- What would go here? Methods? -->
</li>
</ul>
<p>So the following Rust trait</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo&lt;T: Ord&gt;: Bar { }
<span class="boring">}
</span></code></pre></pre>
<p>would be represented as</p>
<pre><code class="language-scheme">(Foo (trait ; KindedVarIds -- the generics:
            ((TyKind Self) (TyKind T))
            ; where clauses, including supertraits:
            ((Implemented (Ord (T))) (Implemented (Bar (Self))))
            ; trait items, empty list:
            ()
            ))
</code></pre>
<h3 id="lowering-crate-items-to-clauses"><a class="header" href="#lowering-crate-items-to-clauses">Lowering crate items to clauses</a></h3>
<p>The next part of <code>formality-decl</code> is the metafunction <code>env-with-crate-decls</code>:</p>
<pre><code class="language-scheme">(define-metafunction formality-decl
  ;; Add the clauses/hypothesis from multiple crates
  ;; into the environment, where CrateId names the current crate.
  env-with-crate-decls : Env CrateDecls CrateId -&gt; Env
  ; ...
  )
</code></pre>
<p><span class="caption"><a href="https://github.com/nikomatsakis/a-mir-formality/blob/47eceea34b5f56a55d781acc73dca86c996b15c5/src/decl/decl-to-clause.rkt#L20-L23">Source</a></span></p>
<p>This metafunction converts <em>Rust declarations</em> into the <em>environment</em> from the type layer.
Note that it takes:</p>
<ul>
<li>a base environment <code>Env</code> (typically just the constant <code>EmptyEnv</code>)</li>
<li>a set of crates <code>CrateDecls</code> (this is meant to include the imports)</li>
<li>the ID of the current crate <code>CrateId</code>.
This is because the set of rules we generate for a particular item
can be different depending on whether we are compiling the crate where it was declared or from some other crate
(consider e.g. <code>#[non_exhaustive]</code>).</li>
</ul>
<h3 id="generating-the-clauses-for-a-single-crate-item"><a class="header" href="#generating-the-clauses-for-a-single-crate-item">Generating the clauses for a single crate item</a></h3>
<p>The <code>env-with-crate-decls</code> function iterates over all the items in all the crates
and ultimately invokes this helper function, <code>crate-item-decl-rules</code>:</p>
<pre><code class="language-scheme">(define-metafunction formality-decl
  ;; Given a crate item, return a tuple of:
  ;;
  ;; * The clauses that hold in all crates due to this item
  ;; * The invariants that hold in all crates due to this item
  ;; * The invariants that hold only in the crate that declared this item
  crate-item-decl-rules : CrateDecls CrateItemDecl -&gt; (Clauses Invariants Invariants)
</code></pre>
<p><span class="caption"><a href="https://github.com/nikomatsakis/a-mir-formality/blob/47eceea34b5f56a55d781acc73dca86c996b15c5/src/decl/decl-to-clause.rkt#L57-L63">Source</a></span></p>
<p><code>crate-item-decl-rules</code> takes </p>
<ul>
<li>the full set of crates <code>CrateDecls</code> and</li>
<li>the declaration of a single item <code>CrateItemDecl</code></li>
</ul>
<p>and it returns a 3-tuple.
As the comment says, this contains both clauses (rules that can be used to derive true facts)
along with two sets of invariants.
We'll cover the invariants later.</p>
<!-- move/copy description of metafunctions to ty chapter -->
<p>Metafunctions are basically a gigantic match statement.
They consist of a series of clauses,
each of which begins with a &quot;pattern match&quot; against the arguments. </p>
<p>To see how it works, let's look at the case for an <code>impl</code> from that section.
To begin with, here is the comment explaining what we aim to do:</p>
<pre><code class="language-scheme"> [;; For an trait impl declared in the crate C, like the following:
   ;;
   ;;     impl&lt;'a, T&gt; Foo&lt;'a, T&gt; for i32 where T: Ord { }
   ;;
   ;; We consider `HasImpl` to hold if (a) all inputs are well formed and (b) where
   ;; clauses are satisfied:
   ;;
   ;;     (ForAll ((LtKind 'a) (TyKind T))
   ;;         (HasImpl (Foo (i32 'a u32))) :-
   ;;             (WellFormed (TyKind i32))
   ;;             (WellFormed (TyKind i32))
   ;;             (Implemented (Ord T)))
</code></pre>
<p>The actual code for this
begins by matching the item that we are generating rules for:</p>
<pre><code class="language-scheme">(crate-item-decl-rules CrateDecls (impl KindedVarIds_impl TraitRef WhereClauses_impl ImplItems))
</code></pre>
<p><span class="caption"><a href="https://github.com/nikomatsakis/a-mir-formality/blob/47eceea34b5f56a55d781acc73dca86c996b15c5/src/decl/decl-to-clause.rkt#L141-L166">Source</a></span></p>
<p>The next line is the final result.
The function this is part of  -- this says we will produce one global clause</p>
<!-- ??? -->
<pre><code class="language-scheme">((Clause) () ())
</code></pre>
<p>This final result is allowed to refer to variables defined on the following lines, shown below.
A <code>(where/error &lt;pattern&gt; &lt;value&gt;)</code> clause is effectively just <code>let &lt;pattern&gt; = &lt;value&gt;</code>, in Rust terms;
the <code>/error</code> part means &quot;if this pattern doesn't match, generate an error&quot;.
You can also write <code>(where &lt;pattern&gt; &lt;value&gt;)</code>, but that means that if the pattern doesn't match, 
the metafunction should to see if the next rule works.</p>
<p>The impl code begins by pattern matching against the <code>TraitRef</code> that the impl is implementing
(in the example from the comment, that would be <code>(Foo (i32 'a T))</code>).
We extract out the <code>TraitId</code> and the self type <code>Parameter_trait</code>:</p>
<pre><code class="language-scheme">   (where/error (TraitId (Parameter_trait ...)) TraitRef)
</code></pre>
<p>Next we look up the definition of the trait itself to find out its generics, using a helper function <code>item-with-id</code>.
This matches and extracts out the parameter kinds (lifetimes vs types, in this code):</p>
<pre><code class="language-scheme">   (where/error (trait KindedVarIds_trait _ _) (item-with-id CrateDecls TraitId))
   (where/error ((ParameterKind_trait _) ...) KindedVarIds_trait)
</code></pre>
<p>Next we convert the where clauses (e,g, <code>T: Ord</code>) into goals, using a helper function <code>where-clauses-to-goals</code> (described below):</p>
<pre><code class="language-scheme">   (where/error (Goal_wc ...) (where-clauses-to-goals WhereClauses_impl))
</code></pre>
<p>Finally we can generate that variable <code>Clause</code> that was referenced in the final result.
Note that we use the <code>...</code> notation to &quot;flatten&quot; together the list of goals from the where-clauses (<code>Goal_wc ...</code>)
and <code>WellFormed</code>-ness goals that we must prove
(i.e., to use the impl, we must show that its input types are well-formed):</p>
<pre><code class="language-scheme">   (where/error Clause (ForAll KindedVarIds_impl
                               (Implies
                                ((WellFormed (ParameterKind_trait Parameter_trait)) ...
                                 Goal_wc ...
                                 )
                                (HasImpl TraitRef))))
   ]
</code></pre>
<p>The <code>where-clause-to-goal</code> helper is fairly simple.
Here is the source, I'll leave puzzling it out as an exercise to the reader:</p>
<pre><code class="language-scheme">(define-metafunction formality-decl
  ;; Convert a where clause `W` into a goal that proves `W` is true.
  where-clause-to-goal : WhereClause -&gt; Goal

  ((where-clause-to-goal (Implemented TraitRef))
   (Implemented TraitRef)
   )

  ((where-clause-to-goal (ForAll KindedVarIds WhereClause))
   (ForAll KindedVarIds Goal)
   (where/error Goal (where-clause-to-goal WhereClause))
   )

  ; FIXME: Support lifetimes, projections
  )
</code></pre>
<p><span class="caption"><a href="https://github.com/nikomatsakis/a-mir-formality/blob/47eceea34b5f56a55d781acc73dca86c996b15c5/src/decl/decl-to-clause.rkt#L197-L211">Source</a></span></p>
<h3 id="generating-the-ok-goals-for-a-crate"><a class="header" href="#generating-the-ok-goals-for-a-crate">Generating the &quot;ok goals&quot; for a crate</a></h3>
<p>In addition to &quot;clauses&quot;, there is also a function <code>crate-ok-goal</code> 
that generate goals for each crate item in a given crate:</p>
<pre><code class="language-scheme">(define-metafunction formality-decl
  ;; Given a set of crates and the decl for the current crate,
  ;; generate the goal that proves all declarations in the current crate are
  ;; &quot;ok&quot;. Other crates are assumed to be &quot;ok&quot;.
  crate-ok-goal : CrateDecls CrateDecl -&gt; Goal
</code></pre>
<p><span class="caption"><a href="https://github.com/nikomatsakis/a-mir-formality/blob/47eceea34b5f56a55d781acc73dca86c996b15c5/src/decl/decl-ok.rkt#L7-L11">Source</a></span></p>
<p>The idea is that the crate is &quot;ok&quot; (i.e., passes the type check) if these goals are satisfied.
For the declarations layer, these goals correspond roughly to rustc's <code>wfcheck</code>.
Here is the rule for impls:</p>
<pre><code class="language-scheme">  [;; For a trait impl declared in the crate C, like the following:
   ;;
   ;;     impl&lt;'a, T&gt; Foo&lt;'a, T&gt; for u32 { }
   ;;
   ;; we require that the trait is implemented.
   (crate-item-ok-goal _ (impl KindedVarIds_impl TraitRef WhereClauses_impl ImplItems))
   (ForAll KindedVarIds_impl
           (Implies ((WellFormed KindedVarId_impl) ... WhereClause_impl ...)
                    (All ((Implemented TraitRef)))))

   (where/error (KindedVarId_impl ...) KindedVarIds_impl)
   (where/error (WhereClause_impl ...) WhereClauses_impl)
   ]
  )
</code></pre>
<p><span class="caption"><a href="https://github.com/nikomatsakis/a-mir-formality/blob/47eceea34b5f56a55d781acc73dca86c996b15c5/src/decl/decl-ok.rkt#L59-L71">Source</a></span></p>
<p>In short, an <code>impl</code> is well-formed if the trait is fully implemented.
We'll look at the definition of <em>implemented</em> in more detail in <a href="./case-study.html">the next section</a>,
but for now it suffices to say that a trait is implemented if
(a) it has an impl and 
(b) all of its where-clauses are satisfied.
Since we know there is an impl (we're checking it right now!) this is equivalent to saying 
&quot;all of the trait's where clauses are satisfied&quot;.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="case-study-implied-bounds-and-perfect-derive"><a class="header" href="#case-study-implied-bounds-and-perfect-derive">Case study: Implied bounds and perfect derive</a></h1>
<p>The <a href="https://github.com/nikomatsakis/rust-name-resolution-algorithm/tree/ccc9599e0db39afa3516cedf059e434d0810be6f">current code</a> doesn't really model Rust as it is today.
It actually models Rust extended with support for two new features:
&quot;implied bounds&quot; and &quot;perfect derive&quot;.</p>
<p><strong>Implied bounds:</strong>
Given <code>struct Foo&lt;T: Ord&gt;</code>, can <code>impl&lt;T&gt; Foo&lt;T&gt; { ... }</code> just know that <code>T: Ord</code>?
We actually have implied bounds today, but they are limited to supertraits (e.g., <code>T: Eq =&gt; T: PartialEq</code>),
so maybe a better way to describe implied bounds would be <em>expanded implied bounds</em>.</p>
<p><strong>Perfect derive:</strong>
Given <code>#[derive(Clone)] struct Foo&lt;T&gt; { x: Rc&lt;T&gt; }</code>,
we &quot;just know&quot; that <code>impl&lt;T&gt; Clone for Foo&lt;T&gt;</code> works,
and that <code>T: Clone</code> is not necessary?
The idea is that <code>derive</code> would generate <code>impl&lt;T&gt; Clone for Foo&lt;T&gt; where Rc&lt;T&gt;: Clone</code>.
Seems simple, right?
The trick is that we have to extend all trait matching to work like auto-traits does,
and accept cycles.
Consider deriving clone on * <code>struct List&lt;T&gt; { value: Rc&lt;T&gt;, next: Option&lt;Rc&lt;List&lt;T&gt;&gt;&gt; }</code>.
Here you would get <code>impl&lt;T&gt; Clone for List&lt;T&gt; where Rc&lt;T&gt;: Clone, Option&lt;Rc&lt;List&lt;T&gt;&gt;&gt;: Clone</code>.
If you try that today, you'll find it is a cycle error.
We are going to refer to this &quot;accept cycles&quot; as coinductive;
it's basically the co-LP formulation by <a href="https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.102.9618&amp;rep=rep1&amp;type=pdf">Luke Simon et al.</a> that I referred to earlier.</p>
<p>These two features are a bit tricky to integrate because accepting cycles, 
if you're not careful, can easily lead you into assuming implied bounds that are not true.
The classic example is this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Copy { }
trait Magic: Copy { }
<span class="boring">}
</span></code></pre></pre>
<p>Clearly, given these traits, we know that <code>T: Magic =&gt; T: Copy</code>, right?
But what about if someone writes this rather tautological impl:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T: Magic&gt; Magic for T { }
<span class="boring">}
</span></code></pre></pre>
<p>If we're not careful, we can use this impl to show that every type implements <code>Magic</code> --
and yet there is no <code>impl Copy</code> anywhere.
Something is off!</p>
<p>The solution to that is based on the scheme that <a href="https://github.com/scalexm">scalexm</a> invented for Chalk;
I've tweaked it somewhat by integrating it a bit more deeply into the &quot;core logic&quot;,
which simplifies the predicates that we need.
I find I like this formulation better, and it allows us to simplify a few other things too.</p>
<h3 id="distinguish-hasimpl-and-implemented"><a class="header" href="#distinguish-hasimpl-and-implemented">Distinguish <code>HasImpl</code> and <code>Implemented</code></a></h3>
<p>The first key part of the system
is to distinguish <em>having an impl</em> (<code>HasImpl</code>) from <em>being implemented</em> (<code>Implemented</code>).
The former says that the user wrote an <code>impl</code> block.
The latter says that all the requirements are met to implement the trait,
including in particular that all of its where clauses (which includes the supertraits) are satisfied.</p>
<p>Using the code for impls we saw earlier, the <code>Magic</code> impl would generate the following clause:</p>
<pre><code class="language-scheme">; forall&lt;T&gt; { Implemented(T: Magic) =&gt; HasImpl(T: Magic) }
(ForAll ((TyKind T)) 
        (Implies ((Implemented (Magic (T))))
                 (HasImpl (Magic (T)))))
</code></pre>
<p>To actually prove <code>Implemented(T: Magic)</code>,
this clause has to be combined with the clauses generated by the trait declarations (<a href="https://github.com/nikomatsakis/a-mir-formality/blob/47eceea34b5f56a55d781acc73dca86c996b15c5/src/decl/decl-to-clause.rkt#L95-L118">source</a>).
For the <code>Copy</code> trait, which has no where clauses, this clause is very simple.
To be implemented, the impl must exist, and the type must be well-formed:</p>
<pre><code class="language-scheme">; forall&lt;T&gt; { (
;               HasImpl(T: Copy), 
;               WellFormed(T),
;             ) =&gt; Implemented(T: Copy) }
(ForAll ((TyKind T))
        (Implies ((HasImpl (Copy (T)))
                  (WellFormed (TyKind (T))))
                 (Implemented (Copy (T)))))
</code></pre>
<p>For <code>Magic</code>, the rule includes the where clause that <code>T: Copy</code>:</p>
<pre><code class="language-scheme">; forall&lt;T&gt; { (
;               HasImpl(T: Magic), 
;               WellFormed(T),
;               Implemented(T: Copy),
;             ) =&gt; Implemented(T: Magic) }
(ForAll ((TyKind T))
        (Implies ((HasImpl (Magic (T)))
                  (WellFormed (TyKind (T)))
                  (Implemented (Copy (T))))
                 (Implemented (Magic (T)))))
</code></pre>
<p>Now we start to see how this works -- 
if I want to call a function with a <code>T: Magic</code> where clause, like this...</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn make_the_magic_happen&lt;T: Magic&gt;(t: T) {
    let u = t;
    drop((t, u)); // both t, u are valid
}
<span class="boring">}
</span></code></pre></pre>
<p>...it is not enough to show that <code>HasImpl</code> is satisfied, I also have to prove that <code>T: Copy</code>
To do that, I have to show that <code>HasImpl(T: Copy)</code>, and I can't do that.</p>
<h3 id="but-wait-implied-bounds"><a class="header" href="#but-wait-implied-bounds">But wait, implied bounds?</a></h3>
<p>Actually though, the above is not sufficient to solve the problem
That's because we haven't added in implied bounds yet! The <em>naive</em> version of implied bounds is that we want to add in a rule like so:</p>
<pre><code>Implemented(T: Magic) =&gt; Implemented(T: Copy)
</code></pre>
<p>i.e., if I know that <code>T: Magic</code>, I also know that <code>T: Copy</code>
But if we literally added that clause, it would be unsound, at least in a coinductive setting
Why is that? Say I want to prove that <code>String: Copy</code>...</p>
<ul>
<li><code>Implemented(String: Copy)</code>? Well, that's true if...
<ul>
<li><code>Implemented(String: Magic)</code>? Well, that's true if...
<ul>
<li><code>HasImpl(String: Magic)</code>? Well, that's true if...
<ul>
<li><code>Implemented(String: Magic)</code> -- and that's on the stack, so that's ok!</li>
</ul>
</li>
<li><code>WellFormed(String)</code> -- yep</li>
<li><code>Implemented(String: Copy)</code> -- well, that's on the stack, so that's ok!</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>The traditional solution so this sort of problem is to impose some kind of limits on the impls people can write so they must be &quot;productive&quot;
It's a bit tricky to define what productivity means, but intuitively it means &quot;not tautological&quot;
The challenge is that the various schemes I've seen for showing productivity don't accept impls like the ones that perfect derive would create, so they wouldn't really work for us.
The solution in the impl works a different way.</p>
<p>The co-LP formulation acccepts any cycle as valid, so it's very easy to create these kind of &quot;tautological rules&quot;.
Now, if the user actually <em>wrote</em> those impls, I don't see that as a problem.
It's ok to have mutually dependent impls, all we want to know basically is &quot;when I call a method, there will be some impl to go to&quot; (see example below).
But it's not good if it's unsound. =)</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo {
    fn foo(&amp;self);
}

trait Bar {
    fn bar(&amp;self);
}

impl&lt;T: Bar&gt; Foo for T {
    fn foo(&amp;self) {
        if something() { self.bar() }
    }
}

impl&lt;T: Foo&gt; Bar for T {
    fn bar(&amp;self) {
        if something() { self.foo() }
    }
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="enter-invariants"><a class="header" href="#enter-invariants">Enter: invariants</a></h3>
<p>The insight is that it's not ok to use implied bounds out of thin air.
You only want to use them for where-clauses that you have in scope.
In this way, they are categorically different from program clauses, which always hold.
I've decided to refer to implied bounds as <em>invariants</em> -- the idea is that they are things which &quot;must be true if the program is valid&quot;.
So for our program we would have one <strong>invariant</strong>:</p>
<pre><code>forall&lt;T&gt; { Implemented(T: Magic) =&gt; Implemented(T: Copy) }
</code></pre>
<p>To express this a bit more formally, let <code>F</code> be the set of all &quot;facts&quot; we can generate from the clauses alone (a &quot;fact&quot; here is just a predicate that refers to some concrete types and thing)s.
Because there are an infinite set of types, the set of facts is also infinite, but that's ok.
In our example, given the rules we've seen so far (but ignoring the implied bound), we can show that <code>HasImpl(i32: Magic)</code> and <code>HasImpl(u32: Magic)</code> easily enough.
We don't have a <code>HasImpl(i32: Copy)</code> fact, though, and because of that we also can't have a <code>Implemented(i32: Copy)</code> fact.
Given this set of facts <code>F</code>, then we ought to be able to prove each invariant <code>I</code>, or something is broken in our type rules.
In our example, the invariant <code>forall&lt;T&gt; { Implemented(T: Magic) =&gt; Implemented(T: Copy) }</code> does in fact hold, because there are no <code>Implemented(T: Magic)</code> facts.</p>
<h3 id="integrating-invariants-into-the-solver"><a class="header" href="#integrating-invariants-into-the-solver">Integrating invariants into the solver</a></h3>
<p>The solver is able to make use of invariants to generate proofs, but only in a limited way.
Whereas we can always use a program clause, we can only apply invariants to the <em>hypotheses</em> that are in scope -- a <em>hypotheses</em> is some where-clause that we are assuming to be true.
The idea here is that the caller must have proven that hypothesis to be a <em>fact</em> -- if they did so, then unless our type rules are broken, the invariant holds, which means that any facts we can derive with the invariants are also true.</p>
<p>This in turn implies that the seemingly tautological impl of <code>Magic</code> is actually <strong>legal</strong>! Recall the &quot;ok goals&quot; we saw before, that are used to decide which declarations are legal.
The &quot;ok&quot; goal for the magic impl looks like this:</p>
<pre><code class="language-scheme">(ForAll ((TyKind T))
        (Implies ((Implemented (Magic (T))))
                 (Implemented (Magic (T)))))
</code></pre>
<p>Basically, &quot;if we assume that <code>T: Magic</code> is implemented, then we can show that <code>T: Magic</code> is implemented&quot;.
Well, that's obviously true.</p>
<p>OK, so the impl is legal, but what about this function <code>make_the_magic_happen</code>?</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn make_the_magic_happen&lt;T: Magic&gt;(t: T) {
    let u = t;
    drop((t, u)); // both t, u are valid
}
<span class="boring">}
</span></code></pre></pre>
<p>We don't currently have type-checking logic in Formality
but, if we did, type-checking this function would require copying <code>t</code> and hence proving that:</p>
<pre><code>forall&lt;T&gt; {
    Implemented(T: Magic) =&gt; Implemented(T: Copy)
}
</code></pre>
<p>Here the <code>Implemented(T: Magic) =&gt; ...</code> comes from the where-clauses on the function.
To solve this, the solver puts <code>Implemented(T: Magic)</code> into the environment as a hypothesis using the &quot;prove-implies&quot; rule (<a href="https://github.com/nikomatsakis/a-mir-formality/blob/47eceea34b5f56a55d781acc73dca86c996b15c5/src/ty/cosld-solve/prove.rkt#L67-L71">source</a>):</p>
<pre><code class="language-scheme">  [(where Env_1 (env-with-hypotheses Env Hypotheses))
   (prove Env_1 Predicates_stack Goal EnvSubstitution_out)
   -------------------------------------------------------- &quot;prove-implies&quot;
   (prove Env Predicates_stack (Implies Hypotheses Goal) (reset Env () EnvSubstitution_out))
   ]
</code></pre>
<p>Next it can apply the &quot;prove-hypothesis-imply&quot; rule (<a href="https://github.com/nikomatsakis/a-mir-formality/blob/47eceea34b5f56a55d781acc73dca86c996b15c5/src/ty/cosld-solve/prove.rkt#L41-L45">source</a>):</p>
<pre><code class="language-scheme">  [(where #f (in? Predicate Predicates_stack))
   (Hypotheses-imply Env () Predicate EnvSubstitution_out)
   --------------- &quot;prove-hypotheses-imply&quot;
   (prove Env Predicates_stack Predicate EnvSubstitution_out)
   ]
</code></pre>
<p>This rule usess <a href="https://github.com/nikomatsakis/a-mir-formality/blob/47eceea34b5f56a55d781acc73dca86c996b15c5/src/ty/cosld-solve/hypothesize.rkt#L9-L11"><code>Hypotheses-imply</code></a>, another typing judgment which determines whether <code>Predicate</code> is either <em>directly</em> in the environment as a hypothesis <strong>or can be derived via an invariant</strong>.
This last part is what we need here! The only hypothesis in the environment is <code>Implemented(T: Magic)</code>, but we can use the invariant</p>
<pre><code>Implemented(T: Magic) =&gt; Implemented(T: Copy)
</code></pre>
<p>to expand that to <code>Implemented(T: Copy)</code>, so we are happy.</p>
<h3 id="wait-so-is-this-sound"><a class="header" href="#wait-so-is-this-sound">Wait, so is this sound?</a></h3>
<p>But accepting this impl and this function this doesn't mean we have an unsound program -- the question is, who is going to <em>call</em> that function, and with what type? And this is where the errors come in.
Consider this <code>main</code> function:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    make_the_magic_happen(&quot;Die, cruel world, die!&quot;.to_string());
}
</code></pre></pre>
<p>For this program to type-check, we must prove the where-clauses on <code>make_the_magic_happen</code>, which means proving</p>
<pre><code>Implemented(String: Magic)
</code></pre>
<p>But in this case, there are no hypotheses in the environment, so we can't make use of the invariants.
We have to use the program clause, it requires also showing that <code>Implemented(String: Copy)</code> which in turn means showing <code>HasImpl(String: Copy)</code>, and we cannot do that.</p>
<p>Thinking a bit more abstractly, no matter what where clauses we have on various functions, we will &quot;bottom out&quot; in a <code>main</code> function somewhere, and <code>main</code> has no where clauses.
Therefore, if our program relies on <code>Implemented(i32: Magic)</code>, that must be provable in an environment with no hypotheses.
Put another way, <code>Implemented(i32: Magic)</code> must be a member of that infinite set of facts that we described earlier, the ones which categorize &quot;everything that is true in this program&quot;.
But we already argued that this set does not include <code>Implemented(i32: Magic)</code>, because the only way to get such a fact is to use the program clause, and the program clause requires that <code>HasImpl(i32: Copy)</code>, which is not true.</p>
<!--
### Productivity again?

xxx -- didn't get time to to finish this, but I think that you can frame the previous two sections in terms of the typical "productivity" rules.
There is a nice thesis I've been slowly working through on this.
The TL;DR is something like this: "we accept all cycles but require that for any proof of `Implemented(T: Foo)`, `HasImpl(T: Foo)` must appear somewhere in the cycle", but that's not quite stating it right.
-->

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            var socket = new WebSocket("ws://localhost:3000/__livereload");
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </body>
</html>
